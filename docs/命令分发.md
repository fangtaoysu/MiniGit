# 命令分发

## 总体设计
- 表示层以 `CommandEngine` 为中心：读取整行命令文本，经 `Lexer` 进行最小词法分析，生成 `CommandContext` 对象，按 `cmd` 字段路由到已注册的验证器与执行器。
- 验证逻辑由 `Validator` 实现，执行逻辑由 `CmdExecutor` 实现。
- 结果以布尔值返回：`true` 成功，`false` 记录错误日志并停止。

## 关键接口与数据
- `presentation::CommandContext`（`src/presentation/model.h`）
  - `cmd`：子命令名（如 `init`、`add`、`commit`）
  - `opts`：可选参数（如 `-m`、`--all`）
  - `args`：普通参数（如 `commit` 后的消息）
  - `file_paths`：文件路径
- `presentation::Validator`（`src/presentation/validator.h`）
  - `bool Validate(const CommandContext&)`
- `application::CmdExecutor`（`src/application/cmd_executor.h`）
  - `bool Execute(const presentation::CommandContext&)`
- `presentation::Lexer`（`src/presentation/lexer.*`）
  - 将输入行拆解为 `CommandContext`，其中 `cmd` 为子命令（如 `git init` → `cmd="init"`）。

### CommandEngine 实现

核心流程（`src/presentation/command_engine.cc`）：
  1. 记录开始日志 → `Lexer` 解析 → 查找 `name = ctx.cmd`
  2. 校验空指针与是否注册 → `validator->Validate(ctx)` → `executor->Execute(ctx)`
  3. 捕获异常并返回 `false`

**NOTE：**
  - 注册时将所有权移交：`{std::move(validator), std::move(executor)}`
  - 执行时不可 `move` 出注册表，否则二次调用将悬空（使用引用访问）

### 错误与日志
- 未知命令/未绑定验证器/执行器/验证失败/执行异常 → 返回 `false`，并通过 `infrastructure::Logger` 输出错误。
- 日志示例：`[presentation/command_engine.cc:16] start execute command: git init`

## 测试
- 位置：`tests/presentation/command_engine_test.cc`
- 场景：
  - 已知命令：`ASSERT_TRUE(engine_.Execute("git stub arg1 arg2"))`，断言执行器被调用且参数传递正确
  - 未知命令：`EXPECT_FALSE(engine_.Execute("unknown"))`
  - 空字符串：`EXPECT_TRUE(engine_.Execute(""))`（不崩溃即可）
- 测试桩：`StubExecutor` 返回 `true` 并记录参数；`SpyValidator` 统计调用次数与参数

### 使用示例
- 在 `src/main.cpp`：
  - 构造 `CommandEngine`，注册：
    - `RegisterCommand("init", make_unique<InitValidator>(), make_unique<InitExecutor>())`
  - 运行：`engine.Execute("git init")`
