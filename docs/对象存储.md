## 项目结构规划

```
src/
├── domain/                          # 领域层
│   ├── core/                       # 核心领域对象
│   │   ├── Blob.h
│   │   ├── Commit.h  
│   │   └── Tree.h
│   └── storage/                    # 存储抽象层
│       ├── repositories/           # 仓储接口
│       │   ├── IObjectRepository.h
│       │   ├── IReferenceRepository.h
│       │   └── IIndexRepository.h
│       └── entities/               # 存储实体
│           ├── GitObjectEntity.h
│           └── ReferenceEntity.h
├── application/                    # 应用层
│   ├── init/                       # init业务
│   │   ├── InitCommand.h
│   │   ├── InitService.h
│   │   └── InitRepositoryImpl.h
│   ├── add/                        # add业务
│   │   ├── AddCommand.h
│   │   ├── AddService.h
│   │   └── AddRepositoryImpl.h
│   ├── commit/                     # commit业务
│   │   ├── CommitCommand.h
│   │   ├── CommitService.h
│   │   └── CommitRepositoryImpl.h
│   └── status/                     # status业务
│       ├── StatusCommand.h
│       ├── StatusService.h
│       └── StatusRepositoryImpl.h
└── infrastructure/                 # 基础设施层
    └── database/
        ├── MySQLConnectionPool.h
        ├── MySQLObjectRepository.h
        ├── MySQLReferenceRepository.h
        ├── MySQLIndexRepository.h
        └── DatabaseConfig.h
```

## 1. 领域层设计 (src/domain)

### 存储抽象接口
```cpp
// src/domain/storage/repositories/IObjectRepository.h
#pragma once
#include <memory>
#include <vector>
#include "../../core/Blob.h"
#include "../../core/Commit.h"
#include "../../core/Tree.h"

namespace domain::storage {

class IObjectRepository {
public:
    virtual ~IObjectRepository() = default;
    
    virtual bool StoreBlob(const core::Blob& Blob) = 0;
    virtual bool StoreCommit(const core::Commit& Commit) = 0;
    virtual bool StoreTree(const core::Tree& Tree) = 0;
    
    virtual std::unique_ptr<core::Blob> LoadBlob(const std::string& Sha1) = 0;
    virtual std::unique_ptr<core::Commit> LoadCommit(const std::string& Sha1) = 0;
    virtual std::unique_ptr<core::Tree> LoadTree(const std::string& Sha1) = 0;
    
    virtual bool Exists(const std::string& Sha1) = 0;
    virtual std::vector<std::string> GetAllObjectHashes() = 0;
};

class IReferenceRepository {
public:
    virtual ~IReferenceRepository() = default;
    
    virtual bool UpdateHead(const std::string& CommitSha1) = 0;
    virtual std::string GetHead() = 0;
    
    virtual bool CreateBranch(const std::string& BranchName, const std::string& CommitSha1) = 0;
    virtual bool DeleteBranch(const std::string& BranchName) = 0;
    virtual std::string GetBranchHead(const std::string& BranchName) = 0;
    
    virtual bool CreateTag(const std::string& TagName, const std::string& CommitSha1) = 0;
    virtual std::string ResolveReference(const std::string& RefName) = 0;
};

class IIndexRepository {
public:
    virtual ~IIndexRepository() = default;
    
    virtual void StageFile(const std::string& FilePath, const std::string& BlobSha1) = 0;
    virtual void UnstageFile(const std::string& FilePath) = 0;
    virtual bool IsStaged(const std::string& FilePath) = 0;
    virtual std::unordered_map<std::string, std::string> GetStagedFiles() = 0;
    virtual void ClearStaged() = 0;
};

} // namespace domain::storage
```

### 存储实体
```cpp
// src/domain/storage/entities/GitObjectEntity.h
#pragma once
#include <string>
#include <vector>

namespace domain::storage::entities {

struct GitObjectEntity {
    std::string Sha1;
    std::string Type;  // "blob", "commit", "tree"
    std::vector<uint8_t> Data;
    size_t Size;
    std::chrono::system_clock::time_point CreatedAt;
};

struct ReferenceEntity {
    std::string Name;     // "HEAD", "refs/heads/main", "refs/tags/v1.0"
    std::string Target;   // commit SHA1 or other reference
    std::string Type;     // "branch", "tag", "head"
};

struct IndexEntryEntity {
    std::string FilePath;
    std::string BlobSha1;
    std::string Mode;     // "100644", "100755", "040000"
    std::chrono::system_clock::time_point StagedAt;
};

} // namespace domain::storage::entities
```

## 2. 应用层设计 (src/application)

### Init业务
```cpp
// src/application/init/InitService.h
#pragma once
#include "../../domain/storage/repositories/IObjectRepository.h"
#include "../../domain/storage/repositories/IReferenceRepository.h"

namespace application::init {

class InitService {
public:
    InitService(std::shared_ptr<domain::storage::IObjectRepository> ObjectRepo,
                std::shared_ptr<domain::storage::IReferenceRepository> RefRepo);
    
    bool InitializeRepository(const std::string& Path);
    bool IsRepositoryInitialized(const std::string& Path);

private:
    std::shared_ptr<domain::storage::IObjectRepository> ObjectRepository;
    std::shared_ptr<domain::storage::IReferenceRepository> ReferenceRepository;
};

} // namespace application::init
```

```cpp
// src/application/init/InitRepositoryImpl.h
#pragma once
#include "../../domain/storage/repositories/IObjectRepository.h"
#include "../../domain/storage/repositories/IReferenceRepository.h"

namespace application::init {

class InitObjectRepository : public domain::storage::IObjectRepository {
    // 初始化专用的存储实现
    // 可以包含文件系统操作等
};

} // namespace application::init
```

### Add业务
```cpp
// src/application/add/AddService.h
#pragma once
#include "../../domain/storage/repositories/IObjectRepository.h"
#include "../../domain/storage/repositories/IIndexRepository.h"
#include "../../domain/core/Blob.h"

namespace application::add {

class AddService {
public:
    AddService(std::shared_ptr<domain::storage::IObjectRepository> ObjectRepo,
               std::shared_ptr<domain::storage::IIndexRepository> IndexRepo);
    
    bool AddFile(const std::string& FilePath);
    bool AddDirectory(const std::string& DirPath);
    std::vector<std::string> GetStagedFiles();

private:
    std::shared_ptr<domain::storage::IObjectRepository> ObjectRepository;
    std::shared_ptr<domain::storage::IIndexRepository> IndexRepository;
    
    domain::core::Blob CreateBlobFromFile(const std::string& FilePath);
};

} // namespace application::add
```

### Commit业务
```cpp
// src/application/commit/CommitService.h
#pragma once
#include "../../domain/storage/repositories/IObjectRepository.h"
#include "../../domain/storage/repositories/IReferenceRepository.h"
#include "../../domain/storage/repositories/IIndexRepository.h"
#include "../../domain/core/Tree.h"
#include "../../domain/core/Commit.h"

namespace application::commit {

class CommitService {
public:
    CommitService(std::shared_ptr<domain::storage::IObjectRepository> ObjectRepo,
                  std::shared_ptr<domain::storage::IReferenceRepository> RefRepo,
                  std::shared_ptr<domain::storage::IIndexRepository> IndexRepo);
    
    std::string CreateCommit(const std::string& Message, 
                            const std::string& Author,
                            const std::string& Committer);
    
    domain::core::Tree BuildTreeFromStaged();
    std::vector<std::string> GetCommitHistory(const std::string& BranchName = "main");

private:
    std::shared_ptr<domain::storage::IObjectRepository> ObjectRepository;
    std::shared_ptr<domain::storage::IReferenceRepository> ReferenceRepository;
    std::shared_ptr<domain::storage::IIndexRepository> IndexRepository;
};

} // namespace application::commit
```

## 3. 基础设施层设计 (src/infrastructure/database)

### MySQL连接池
```cpp
// src/infrastructure/database/MySQLConnectionPool.h
#pragma once
#include <mysql_driver.h>
#include <mysql_connection.h>
#include <cppconn/statement.h>
#include <cppconn/prepared_statement.h>
#include <queue>
#include <mutex>
#include <condition_variable>

namespace infrastructure::database {

class MySQLConnectionPool {
public:
    static MySQLConnectionPool& GetInstance();
    
    std::shared_ptr<sql::Connection> GetConnection();
    void ReturnConnection(std::shared_ptr<sql::Connection> Conn);
    
    void Initialize(const std::string& Host, const std::string& User, 
                   const std::string& Password, const std::string& Database,
                   int PoolSize = 10);

private:
    MySQLConnectionPool() = default;
    
    std::queue<std::shared_ptr<sql::Connection>> Connections;
    std::mutex Mutex;
    std::condition_variable Condition;
    int MaxPoolSize;
};

} // namespace infrastructure::database
```

### MySQL存储实现
```cpp
// src/infrastructure/database/MySQLObjectRepository.h
#pragma once
#include "../../domain/storage/repositories/IObjectRepository.h"
#include "MySQLConnectionPool.h"

namespace infrastructure::database {

class MySQLObjectRepository : public domain::storage::IObjectRepository {
public:
    MySQLObjectRepository();
    
    bool StoreBlob(const domain::core::Blob& Blob) override;
    bool StoreCommit(const domain::core::Commit& Commit) override;
    bool StoreTree(const domain::core::Tree& Tree) override;
    
    std::unique_ptr<domain::core::Blob> LoadBlob(const std::string& Sha1) override;
    std::unique_ptr<domain::core::Commit> LoadCommit(const std::string& Sha1) override;
    std::unique_ptr<domain::core::Tree> LoadTree(const std::string& Sha1) override;
    
    bool Exists(const std::string& Sha1) override;
    std::vector<std::string> GetAllObjectHashes() override;

private:
    MySQLConnectionPool& ConnectionPool;
    
    bool StoreObject(const std::string& Sha1, const std::string& Type, 
                    const std::vector<uint8_t>& Data);
    std::vector<uint8_t> LoadObjectData(const std::string& Sha1);
};

} // namespace infrastructure::database
```

## 4. 数据库表结构设计

```sql
-- Git对象表
CREATE TABLE git_objects (
    sha1 CHAR(40) PRIMARY KEY,
    type ENUM('blob', 'commit', 'tree') NOT NULL,
    data LONGBLOB NOT NULL,
    size INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_type (type),
    INDEX idx_created_at (created_at)
);

-- 引用表
CREATE TABLE references (
    name VARCHAR(255) PRIMARY KEY,
    target VARCHAR(40) NOT NULL,
    type ENUM('head', 'branch', 'tag') NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_type (type),
    INDEX idx_target (target)
);

-- 暂存区表
CREATE TABLE staging_index (
    file_path VARCHAR(1024) PRIMARY KEY,
    blob_sha1 CHAR(40) NOT NULL,
    mode VARCHAR(6) NOT NULL DEFAULT '100644',
    staged_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_blob_sha1 (blob_sha1)
);

-- 提交历史表（优化查询）
CREATE TABLE commit_history (
    commit_sha1 CHAR(40) PRIMARY KEY,
    tree_sha1 CHAR(40) NOT NULL,
    parent_commits JSON,
    author VARCHAR(255) NOT NULL,
    committer VARCHAR(255) NOT NULL,
    message TEXT,
    commit_time TIMESTAMP NOT NULL,
    INDEX idx_tree_sha1 (tree_sha1),
    INDEX idx_commit_time (commit_time)
);
```

## 5. 依赖注入配置

```cpp
// DependencyConfig.h
#pragma once
#include "src/domain/storage/repositories/IObjectRepository.h"
#include "src/domain/storage/repositories/IReferenceRepository.h"
#include "src/domain/storage/repositories/IIndexRepository.h"
#include "src/infrastructure/database/MySQLObjectRepository.h"
#include "src/infrastructure/database/MySQLReferenceRepository.h"
#include "src/infrastructure/database/MySQLIndexRepository.h"
#include "src/application/init/InitService.h"
#include "src/application/add/AddService.h"
#include "src/application/commit/CommitService.h"

class DependencyConfig {
public:
    static std::shared_ptr<domain::storage::IObjectRepository> CreateObjectRepository() {
        return std::make_shared<infrastructure::database::MySQLObjectRepository>();
    }
    
    static std::shared_ptr<domain::storage::IReferenceRepository> CreateReferenceRepository() {
        return std::make_shared<infrastructure::database::MySQLReferenceRepository>();
    }
    
    static std::shared_ptr<domain::storage::IIndexRepository> CreateIndexRepository() {
        return std::make_shared<infrastructure::database::MySQLIndexRepository>();
    }
    
    static std::shared_ptr<application::init::InitService> CreateInitService() {
        return std::make_shared<application::init::InitService>(
            CreateObjectRepository(), CreateReferenceRepository());
    }
    
    static std::shared_ptr<application::add::AddService> CreateAddService() {
        return std::make_shared<application::add::AddService>(
            CreateObjectRepository(), CreateIndexRepository());
    }
    
    static std::shared_ptr<application::commit::CommitService> CreateCommitService() {
        return std::make_shared<application::commit::CommitService>(
            CreateObjectRepository(), CreateReferenceRepository(), CreateIndexRepository());
    }
};
```