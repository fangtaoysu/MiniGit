## 项目结构规划

```
src/
├── domain/                          # 领域层
│   ├── core/                       # 核心领域对象
│   │   ├── Blob.h
│   │   ├── Commit.h  
│   │   └── Tree.h
│   └── storage/                    # 存储抽象层
│       ├── repositories/           # 仓储接口
│       │   ├── IObjectRepository.h
│       │   ├── IReferenceRepository.h
│       │   └── IIndexRepository.h
│       └── entities/               # 存储实体
│           ├── GitObjectEntity.h
│           └── ReferenceEntity.h
├── application/                    # 应用层
│   ├── init/                       # init业务
│   │   ├── InitCommand.h
│   │   ├── InitService.h
│   │   └── InitRepositoryImpl.h
│   ├── add/                        # add业务
│   │   ├── AddCommand.h
│   │   ├── AddService.h
│   │   └── AddRepositoryImpl.h
│   ├── commit/                     # commit业务
│   │   ├── CommitCommand.h
│   │   ├── CommitService.h
│   │   └── CommitRepositoryImpl.h
│   └── status/                     # status业务
│       ├── StatusCommand.h
│       ├── StatusService.h
│       └── StatusRepositoryImpl.h
└── infrastructure/                 # 基础设施层
    └── database/
        ├── MySQLConnectionPool.h
        ├── MySQLObjectRepository.h
        ├── MySQLReferenceRepository.h
        ├── MySQLIndexRepository.h
        └── DatabaseConfig.h
```

## 1. 领域层设计 (src/domain)

### 存储抽象接口
```cpp
// src/domain/storage/repositories/i_object_repository.h
#pragma once
#include <memory>
#include <vector>
#include "../../core/blob.h"
#include "../../core/commit.h"
#include "../../core/tree.h"

namespace domain::storage {

class IObjectRepository {
public:
    virtual ~IObjectRepository() = default;
    
    virtual bool StoreBlob(const core::Blob& blob) = 0;
    virtual bool StoreCommit(const core::Commit& commit) = 0;
    virtual bool StoreTree(const core::Tree& tree) = 0;
    
    virtual std::unique_ptr<core::Blob> LoadBlob(const std::string& sha1) = 0;
    virtual std::unique_ptr<core::Commit> LoadCommit(const std::string& sha1) = 0;
    virtual std::unique_ptr<core::Tree> LoadTree(const std::string& sha1) = 0;
    
    virtual bool Exists(const std::string& sha1) = 0;
    virtual std::vector<std::string> GetAllObjectHashes() = 0;
};

class IReferenceRepository {
public:
    virtual ~IReferenceRepository() = default;
    
    virtual bool UpdateHead(const std::string& commit_sha1) = 0;
    virtual std::string GetHead() = 0;
    
    virtual bool CreateBranch(const std::string& branch_name, const std::string& commit_sha1) = 0;
    virtual bool DeleteBranch(const std::string& branch_name) = 0;
    virtual std::string GetBranchHead(const std::string& branch_name) = 0;
    
    virtual bool CreateTag(const std::string& tag_name, const std::string& commit_sha1) = 0;
    virtual std::string ResolveReference(const std::string& ref_name) = 0;
};

class IIndexRepository {
public:
    virtual ~IIndexRepository() = default;
    
    virtual void StageFile(const std::string& file_path, const std::string& blob_sha1) = 0;
    virtual void UnstageFile(const std::string& file_path) = 0;
    virtual bool IsStaged(const std::string& file_path) = 0;
    virtual std::unordered_map<std::string, std::string> GetStagedFiles() = 0;
    virtual void ClearStaged() = 0;
};

} // namespace domain::storage
```

### 存储实体
```cpp
// src/domain/storage/entities/git_object_entity.h
#pragma once
#include <string>
#include <vector>

namespace domain::storage::entities {

struct GitObjectEntity {
    std::string sha1;
    std::string type;  // "blob", "commit", "tree"
    std::vector<uint8_t> data;
    size_t size;
    std::chrono::system_clock::time_point created_at;
};

struct ReferenceEntity {
    std::string name;     // "HEAD", "refs/heads/main", "refs/tags/v1.0"
    std::string target;   // commit SHA1 or other reference
    std::string type;     // "branch", "tag", "head"
};

struct IndexEntryEntity {
    std::string file_path;
    std::string blob_sha1;
    std::string mode;     // "100644", "100755", "040000"
    std::chrono::system_clock::time_point staged_at;
};

} // namespace domain::storage::entities
```

## 2. 应用层设计 (src/application)

### Init业务
```cpp
// src/application/init/init_service.h
#pragma once
#include "../../domain/storage/repositories/i_object_repository.h"
#include "../../domain/storage/repositories/i_reference_repository.h"

namespace application::init {

class InitService {
public:
    InitService(std::shared_ptr<domain::storage::IObjectRepository> object_repo,
                std::shared_ptr<domain::storage::IReferenceRepository> ref_repo);
    
    bool InitializeRepository(const std::string& path);
    bool IsRepositoryInitialized(const std::string& path);

private:
    std::shared_ptr<domain::storage::IObjectRepository> object_repository_;
    std::shared_ptr<domain::storage::IReferenceRepository> reference_repository_;
};

} // namespace application::init
```

```cpp
// src/application/init/init_repository_impl.h
#pragma once
#include "../../domain/storage/repositories/i_object_repository.h"
#include "../../domain/storage/repositories/i_reference_repository.h"

namespace application::init {

class InitObjectRepository : public domain::storage::IObjectRepository {
    // 初始化专用的存储实现
    // 可以包含文件系统操作等
};

} // namespace application::init
```

### Add业务
```cpp
// src/application/add/add_service.h
#pragma once
#include "../../domain/storage/repositories/i_object_repository.h"
#include "../../domain/storage/repositories/i_index_repository.h"
#include "../../domain/core/blob.h"

namespace application::add {

class AddService {
public:
    AddService(std::shared_ptr<domain::storage::IObjectRepository> object_repo,
               std::shared_ptr<domain::storage::IIndexRepository> index_repo);
    
    bool AddFile(const std::string& file_path);
    bool AddDirectory(const std::string& dir_path);
    std::vector<std::string> GetStagedFiles();

private:
    std::shared_ptr<domain::storage::IObjectRepository> object_repository_;
    std::shared_ptr<domain::storage::IIndexRepository> index_repository_;
    
    domain::core::Blob CreateBlobFromFile(const std::string& file_path);
};

} // namespace application::add
```

### Commit业务
```cpp
// src/application/commit/commit_service.h
#pragma once
#include "../../domain/storage/repositories/i_object_repository.h"
#include "../../domain/storage/repositories/i_reference_repository.h"
#include "../../domain/storage/repositories/i_index_repository.h"
#include "../../domain/core/tree.h"
#include "../../domain/core/commit.h"

namespace application::commit {

class CommitService {
public:
    CommitService(std::shared_ptr<domain::storage::IObjectRepository> object_repo,
                  std::shared_ptr<domain::storage::IReferenceRepository> ref_repo,
                  std::shared_ptr<domain::storage::IIndexRepository> index_repo);
    
    std::string CreateCommit(const std::string& message, 
                            const std::string& author,
                            const std::string& committer);
    
    domain::core::Tree BuildTreeFromStaged();
    std::vector<std::string> GetCommitHistory(const std::string& branch_name = "main");

private:
    std::shared_ptr<domain::storage::IObjectRepository> object_repository_;
    std::shared_ptr<domain::storage::IReferenceRepository> reference_repository_;
    std::shared_ptr<domain::storage::IIndexRepository> index_repository_;
};

} // namespace application::commit
```

## 3. 基础设施层设计 (src/infrastructure/database)

### MySQL连接池
```cpp
// src/infrastructure/database/mysql_connection_pool.h
#pragma once
#include <mysql_driver.h>
#include <mysql_connection.h>
#include <cppconn/statement.h>
#include <cppconn/prepared_statement.h>
#include <queue>
#include <mutex>
#include <condition_variable>

namespace infrastructure::database {

class MySQLConnectionPool {
public:
    static MySQLConnectionPool& GetInstance();
    
    std::shared_ptr<sql::Connection> GetConnection();
    void ReturnConnection(std::shared_ptr<sql::Connection> conn);
    
    void Initialize(const std::string& host, const std::string& user, 
                   const std::string& password, const std::string& database,
                   int pool_size = 10);

private:
    MySQLConnectionPool() = default;
    
    std::queue<std::shared_ptr<sql::Connection>> connections_;
    std::mutex mutex_;
    std::condition_variable condition_;
    int max_pool_size_;
};

} // namespace infrastructure::database
```

### MySQL存储实现
```cpp
// src/infrastructure/database/mysql_object_repository.h
#pragma once
#include "../../domain/storage/repositories/i_object_repository.h"
#include "mysql_connection_pool.h"

namespace infrastructure::database {

class MySQLObjectRepository : public domain::storage::IObjectRepository {
public:
    MySQLObjectRepository();
    
    bool StoreBlob(const domain::core::Blob& blob) override;
    bool StoreCommit(const domain::core::Commit& commit) override;
    bool StoreTree(const domain::core::Tree& tree) override;
    
    std::unique_ptr<domain::core::Blob> LoadBlob(const std::string& sha1) override;
    std::unique_ptr<domain::core::Commit> LoadCommit(const std::string& sha1) override;
    std::unique_ptr<domain::core::Tree> LoadTree(const std::string& sha1) override;
    
    bool Exists(const std::string& sha1) override;
    std::vector<std::string> GetAllObjectHashes() override;

private:
    MySQLConnectionPool& connection_pool_;
    
    bool StoreObject(const std::string& sha1, const std::string& type, 
                    const std::vector<uint8_t>& data);
    std::vector<uint8_t> LoadObjectData(const std::string& sha1);
};

} // namespace infrastructure::database
```

## 4. 数据库表结构设计

```sql
-- Git对象表
CREATE TABLE git_objects (
    sha1 CHAR(40) PRIMARY KEY,
    type ENUM('blob', 'commit', 'tree') NOT NULL,
    data LONGBLOB NOT NULL,
    size INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_type (type),
    INDEX idx_created_at (created_at)
);

-- 引用表
CREATE TABLE references (
    name VARCHAR(255) PRIMARY KEY,
    target VARCHAR(40) NOT NULL,
    type ENUM('head', 'branch', 'tag') NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_type (type),
    INDEX idx_target (target)
);

-- 暂存区表
CREATE TABLE staging_index (
    file_path VARCHAR(1024) PRIMARY KEY,
    blob_sha1 CHAR(40) NOT NULL,
    mode VARCHAR(6) NOT NULL DEFAULT '100644',
    staged_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_blob_sha1 (blob_sha1)
);

-- 提交历史表（优化查询）
CREATE TABLE commit_history (
    commit_sha1 CHAR(40) PRIMARY KEY,
    tree_sha1 CHAR(40) NOT NULL,
    parent_commits JSON,
    author VARCHAR(255) NOT NULL,
    committer VARCHAR(255) NOT NULL,
    message TEXT,
    commit_time TIMESTAMP NOT NULL,
    INDEX idx_tree_sha1 (tree_sha1),
    INDEX idx_commit_time (commit_time)
);
```

## 5. 依赖注入配置

```cpp
// dependency_config.h
#pragma once
#include "src/domain/storage/repositories/i_object_repository.h"
#include "src/domain/storage/repositories/i_reference_repository.h"
#include "src/domain/storage/repositories/i_index_repository.h"
#include "src/infrastructure/database/mysql_object_repository.h"
#include "src/infrastructure/database/mysql_reference_repository.h"
#include "src/infrastructure/database/mysql_index_repository.h"
#include "src/application/init/init_service.h"
#include "src/application/add/add_service.h"
#include "src/application/commit/commit_service.h"

class DependencyConfig {
public:
    static std::shared_ptr<domain::storage::IObjectRepository> CreateObjectRepository() {
        return std::make_shared<infrastructure::database::MySQLObjectRepository>();
    }
    
    static std::shared_ptr<domain::storage::IReferenceRepository> CreateReferenceRepository() {
        return std::make_shared<infrastructure::database::MySQLReferenceRepository>();
    }
    
    static std::shared_ptr<domain::storage::IIndexRepository> CreateIndexRepository() {
        return std::make_shared<infrastructure::database::MySQLIndexRepository>();
    }
    
    static std::shared_ptr<application::init::InitService> CreateInitService() {
        return std::make_shared<application::init::InitService>(
            CreateObjectRepository(), CreateReferenceRepository());
    }
    
    static std::shared_ptr<application::add::AddService> CreateAddService() {
        return std::make_shared<application::add::AddService>(
            CreateObjectRepository(), CreateIndexRepository());
    }
    
    static std::shared_ptr<application::commit::CommitService> CreateCommitService() {
        return std::make_shared<application::commit::CommitService>(
            CreateObjectRepository(), CreateReferenceRepository(), CreateIndexRepository());
    }
};
```